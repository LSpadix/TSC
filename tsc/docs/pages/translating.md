Translating TSC
===============

The various messages contained in TSC that are shown to the user can
be translated so that the final user can use an application that uses
a language he is familar with. For this purpose, TSC employs the [GNU
Gettext library](https://www.gnu.org/software/gettext) that consists
of a specialized internationalization library (`libintl`) and a set of
tools used to manage translation files.

Although it is not required for the translation process, it is
recommended that you have a look at the [Gettext
manual](https://www.gnu.org/software/gettext/manual/gettext.html). It
will explain to you the problems and best practises of
internationalization and make you familiar with the Gettext toolchain.

Prerequisites
-------------

For translating, you will need the following things:

1. Git
2. A Git checkout of the game’s repository.
3. Ruby 1.9 or later with Rake installed
4. A text editor

### Git ###

Install the `git` or `git-core` package from your Linux distribution’s
repositories.

### Git checkout ###

TSC uses multiple branches for development so you have to decide on
which branch you want to work on. In short, the `devel` branch is an
ever-changing target, because it contains the most recent additions to
the source code that will change translation strings all the
time. Therefore, if a `release-X.X.X` branch exists (where the Xes are
numbers), it is recommended to do translation work on that branch. You
can view the available branches [on the online repository
viewer](https://github.com/Secretchronicles/TSC).

Once you have decided on the branch to work on, open up a console and
run the following commands:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$ git clone git://github.com/Secretchronicles/TSC.git
$ cd TSC
$ git checkout branchname
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

where you replace `branchname` with the name of the branch you want to
work on, e.g. `release-2.0.0`.

### Ruby with rake ###

Install the `ruby` and `rake` packages from your Linux distribution’s
repositories. Debian has a package named `ruby-full` that is
preferred as it pulls in Rake automatically.

### Text editor ###

The format used by Gettext for translations is known as “PO”. It’s a
_plaintext_ format and as such can be edited with any editor. However,
it follows a distinct structure that, if violated, makes the
translation file unusable for the developers. It is therefore
recommended that you install a specialised PO editor that
automatically ensures that you don’t screw the format up. A very good
start is a tool named [Poedit](http://poedit.net/), which should be
available in the repositories of all major Linux distributions. If you
already know [Emacs](https://www.gnu.org/software/emacs/), there’s a
special [`po-mode` available](http://www.emacswiki.org/emacs/PoMode)
for it.

Glossary
--------

* "i18n" is short for "internationalisation".
* "l10n" is short for "localisation"

Overview
--------

The translations are managed as `.po` files below the
`data/translations` directory, where each available locale is
represented as a single `.po` file containing the two-letter locale
code (e.g. `es` is the Spanish locale). Locale names with four letters
and an underscore denote a specific sublocale that usually slightly
differs from the culture’s canonical locale (e.g. `pt_BR` represents
the Portugese locale as practised in Brazil).

The `.po` files are those you usually do your edits in when you
translate the game. All `.po` files are derived from a master template
file, the `.pot` file (`Secretchronicles.pot`) that should
always match the current state of TSC’s sourcecode with regard to new
strings, removed strings, updated strings, etc. Naturally, as TSC
evolves, your `.po` file falls behind the state of TSC’s sourcecode
and thus behind the status denoted by the master `.pot` template
file.

The `.pot` master template file is not intended to be touched by
translators. It is generated by the developers by means of a specific
program, `xgettext`, that parses the TSC sources and updates the
`.pot` file with what it finds there.

How to update a translation
---------------------------

As a translator, the main thing you want to do is probably to
translate strings. As outlined already, you want to work on the `.po`
file for your respective locale therefore. Before you can start with
this, you have to ensure your locale’s `.po` file matches the master
`.pot` template file, and if it doesn’t, merge against it.

If for example you want to update the Spanish locale, you want to work
on the `es.po` file. The first thing to do is to bring it up to date
with the master `.pot` template file, which you can do either by
calling the `msgmerge` program directly or (recommended) by relying on
the Rake tasks the developers defined for you. Open a commandline
window, change to the directory containing the `.po` files (in the TSC
source tree, this is `tsc/data/translations/`) and execute this:

~~~~~~~~~~~~~~~~~~~~
$ rake es.po
.............................................. done.
~~~~~~~~~~~~~~~~~~~~

Now the `es.po` file is up-to-date and you can start working on
it. Please use a specialised PO Editor for this as outlined above.

The first thing you have to do when working with a `.po` file for the
first time is adapting the PO header, i.e. the translation for the
first `msgid` string right at the top (the one that starts with
`Project-Id-Version`). The first four fields (until
`PO-Revision-Date`) are usually updated by the toolchain and/or your
PO editor, so you should not care about them. The other fields might
need modification to properly instruct Gettext’s localisation
routines. Most importantly, set the `Language` field to your locale’s
two or four-letter code and set `Content-Type` to `text/plain;
charset=UTF-8` unless you have a very good reason to not use UTF-8 for
your translations (there’s never a good reason to not use UTF-8). Next
you have to tell Gettext how your language handles pluralization by
adding a `Plural-Forms` field to the PO header as described under
section 11.2.6 "Additional functions for plural forms" of the Gettext
manual (skip the part that talks about the functions, and start with
the paragraph that starts with "Now, how do these functions solve the
problem of the plural forms?"). That section contains a list of useful
`Plural-Forms` declarations you can use. Reading the manual, you find
that the `Plural-Forms` declaration for Spanish is explicitely
mentioned there as follows:

~~~~~~~~~~~~~~~~~~~~
Plural-Forms: nplurals=2; plural=n != 1;
~~~~~~~~~~~~~~~~~~~~

The manual also describes what do do if it doesn’t contain an explicit
example for your language. You are then of course required to know
your language’s pluralisation rules very good.

Once done, your PO header should look something like this:

~~~~~~~~~~~~~~~~~~~~{.po}
"Project-Id-Version: The Secret Chronicles of Dr. M.\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-08-30 21:36+0200\n"
"PO-Revision-Date: 2014-08-30 19:40+0200\n"
"Last-Translator: You <you@example.com>\n"
"Language-Team: TSC Spanish localization team <tsc-es@example.com>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
~~~~~~~~~~~~~~~~~~~~

Now you can start translating the rest of the `.po` file.

Note that the comment block right before the PO header’s `msgid` is to
your disposal (except for the copyright notice). You can use it to
introduce your fellow translators to some conventions you use in the
translation or how to contact you, or whatever you judge to be
important. For a German locale, you could for example explain whether
to use the formal `Sie` form of addressing the user or the informal
`Du`.

Don’t forget to add a copyright statement for yourself to the PO
header’s comment block.

In any case, once you have done your edits, verify you did not
introduce PO formatting errors by either running it manually through
`msgfmt` or (recommended) by executing this:

~~~~~~~~~~~~~~~~~~~~
$ rake checkpo
[much output]
~~~~~~~~~~~~~~~~~~~~

You will see error and warning messages if you made a mistake, plus
nice statistics on how much you already translated.

Special cases
-------------

Usually the strings to translate look like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.po}
#: ../../src/gui/menu_data.cpp:1585
msgid "Enable to play Sounds."
msgstr "Aktiviere um Sounds abzuspielen."
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`msgid` is the key under which the string is looked up, and `mgstr` is
your translation. Occasionally, however, you encounter strings that
look like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.po}
#. TRANS: Key on a keyboard
#: ../../src/gui/menu_data.cpp:1634
msgid "Key"
msgstr "Taste"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`TRANS` comments are left by the developers and are intended as a help
for translation if a word is not unique or to give additional
information that may be useful for translation.

Or you may find something like this:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.po}
#: ../../src/gui/menu_data.cpp:1632 ../../src/gui/menu_data.cpp:1755
msgctxt "action"
msgid "Name"
msgstr "Name"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`msgcxt` lines denote a context in which a word is used. They are used
when the same word (in English) is used in different situations
(e.g. “game” may either mean playing something, or animals in hunting
terminology — not that this is used in TSC, but I wanted to give an
example), so that translators can translate the same word differently
depending on the context.

Sending your translation upstream
---------------------------------

Any translation is greatly appreciated. It is impossible for us
developers to translate the game in all the languages out there in the
world, so please _do_ submit your translation! You can do it in one of
the following ways:

* Open an issue ticket or pull request on the tracker at
  https://github.com/Secretchronicles/TSC/issues
* Write an email to the [mailinglist](https://lists.secretchronicles.org/).

If you don’t submit through the forum (where the following is covered
by the forum rules) or the mailinglist (same there), please
explicitely state something like “I license my translation as
CC-BY 4.0” so that we have certainty over the legal situation.

Appendix
--------

The following sections are partly informational and partly for
reference by developers. As a translator, you don’t have to care about
them.

### Appendix A: Generating the POT file ###

Use this to have `xgettext` scan through TSC’s sources and update the
`.pot` file:

~~~~~~~~~~~~~~~~~~~~
$ rake potfile
~~~~~~~~~~~~~~~~~~~~

### Appendix B: Guidelines for developers ###

Rule No. 1: Read the [Gettext manual](https://www.gnu.org/software/gettext/manual).

As a developer, always use the macros defined at the top of `i18n.hpp`
for retrieving the translations in the C++ code. Don’t call gettext()
directly, or your strings will not be found by `xgettext`. If for
example you want to make "Hello, world" translatable, this is how it
would look like:

~~~~~~~~~~~~~~~~~~{.cpp}
std::cout << _("Hello, world") << std::endl;
~~~~~~~~~~~~~~~~~~

This way, `xgettext` as called by `rake potfile` will find the string
and add it to the `.pot` file so that translators can find it. The
`UTF8_()` macro is specific to translation of CEGUI strings (see
below).

Be sure to use the `PL_()` macro when you have messages that report
amounts of something. Different languages can have more plural forms
than English (such as different forms for "one", "two", and "anything
above") and you should let the translator decide how many plural forms
he needs. The `PL_()` macro allows you to directly specifcy a singular
and a plural version for English, and Gettext will use that
information to allow the translator to use any number of plurals he
needs:

~~~~~~~~~~~~~~~~~~{.cpp}
printf(PL_("You found one item", "You found %d items", item_count), item_count);
puts("\n");
~~~~~~~~~~~~~~~~~~

For interpolating numbers into strings, you have to use format
strings, most likely with `sprintf()`, because the order of words is
likely to be different in languages other than English, so that you
can’t predict where to put the number. Be careful to make the `sprintf()`
buffer large enough, because the target language may use significantly
more bytes for the same message as English (think especially non-latin
based languages).

~~~~~~~~~~~~~~~~~~{.cpp}
char buf[500];
sprintf(buf, _("I greet %d people"), num_people);

display(buf, num_people);
~~~~~~~~~~~~~~~~~~

Be sure to leave `TRANS` comments in the code where the meaning of a
word is not clear enough or where you think adding information may
prove useful for the translators. `rake potfile` intructs `xgettext`
to add these comments right before the next `msgid` it encounters:

~~~~~~~~~~~~~~~~~~{.cpp}
// TRANS: "Key" as in "keyhole", not as in "keyboard"
std::cout << _("Select key:");
~~~~~~~~~~~~~~~~~~

If you encounter a very short string that needs to be translated, and
you know that this string is used in a completely different meaning
elsewhere, use _contexts_ to prevent Gettext from merging both uses
into one, as in other languages it is likely that the two meanings of
the English word result in actually two different words in the target
language. "Game" for example may be used as in "playing", or as in
"hunting", where in German the correct translation for the first use
is "Spiel" and the one for the latter use is "Wild". Contexts are
easily set up by using the `C_()` macro instead of `_()`.

~~~~~~~~~~~~~~~~~~{.cpp}
std::cout << C_("playing", "game") << std::endl;
std::cout << C_("hunting", "game") << std::endl;
~~~~~~~~~~~~~~~~~~

In that example, `xgettext` will add _two_ entries to the `.pot`
file. Also, please always use _lowercase_ for the context names.

#### Translation of GUI elements

The above works fine for any strings that are not managed by CEGUI,
e.g. console output or strings directly given to SFML. Translating
CEGUI elements is quite a bit more involved, because *CEGUI on itself
does not have i18n capabilities*. That is, you can't just have CEGUI
automatically translate any texts.

You should first understand how CEGUI works. For that, refer to the
[CEGUI documentation](http://static.cegui.org.uk/docs/), specifically
read the "Beginner's Tutorials". From these tutorials, you will learn
that the actual GUI layout is described using XML files. Those we're
interested in for translation are the `.layout` XML files as these
describe where CEGUI places what on the GUI. In TSC, these files are
stored in the `tsc/data/gui/layouts` directory and are announced to
CEGUI in `cVideo::Init_CEGUI()`. To understand what this function does,
refer to the aforementioned CEGUI tutorials.

When TSC wants to draw a GUI window, what happens is this:

1. CEGUI is asked to load a specific layout XML file.
2. Using specific CEGUI getter methods, the target window's C++
   representation (object) is retrieved from CEGUI.
3. Any custom modifications to the window object that
   cannot be done in XML are executed by TSC.
4. The window is shown on the screen.

The translation of GUI strings shown via CEGUI happens in step 3
above, because CEGUI's layout XML does not allow for translations.
TSC resorts to a small hack to allow for translation of GUI strings:
the string for a GUI element as written down in the layout XML file is
replaced at runtime by TSC. TSC invokes one of the i18n functions
described above (usually `UTF8_()`, see below) and replaces the GUI
element's content with the result from Gettext. Since one cannot give
dynamic strings to Gettext (`xgettext` would not be able to extract
them from the code for translation), the string is repeated in the
code for translation rather than just taken from the XML. In
consequence, after the hack has been applied, the static string that
is used in the layout XML file is *never actually shown to the user*
anymore.

In order to make a specific string in the GUI translatable, you thus
have to:

1. Find out in which layout XML file the string resides.
2. Find the element whose text you want to translate.
3. Find the place in the code where the XML file is loaded.
4. Find the place in the code where the element is retrieved.
   It may happen that the element itself is not retrieved.
   TSC usually fetches the entire window from CEGUI and displays
   that. In that case, you need to call some CEGUI functions to
   wire out the actual element you want to translate so that you
   can
5. Apply the hack described above.

**Important note**: When passing translated strings to CEGUI
functions, always use the translation macro `UTF8_()`. This macro does
some type casting required to make CEGUI aware that the string it
receives is already encoded in UTF-8 (just look up its definition in
`i18n.hpp`). If you use the ordinary `_()` macro family, CEGUI thinks
it is passed ISO-8859-* and wants to transcode the string into UTF-8,
resulting in garbage.

The entire process is illustrated by the following example. In the
Options menu, on the initial "Game" tab, there is an option called
"Always Run", which is associated with a combobox. Suppose that option
was not yet translated. What you would do is the following:

1. Find out which part of TSC's C++ code is responsible for drawing
   the "Game" options menu. After hours of digging around, you finally
   arrive at `cMenu_Options::Init_GUI_Game()` in `gui/menu_data.cpp`,
   because you successfully found that the combobox for that option
   is bound to a variable with the fitting name
   `m_game_combo_always_run` (which you probably found with grep(1)).
2. Now you look around the code to find out where that variable
   receives its value. You find this line in `menu_data.cpp`:

       m_game_combo_always_run = static_cast<CEGUI::Combobox*>(p_root->getChild("options/window_options/tabcontrol_main/tab_game/game_combo_always_run"));

3. This is a good hint. It tells you that the combobox is a
   grandgrand...grandchild of a CEGUI window that is bound to the
   `p_root` variable. Take note of the argument to `getChild()`,
   you'll need it later.
4. For the purpose of this example, we suppose that the label that
   shows the static string "Always Run" next to the combobox does not
   already appear in the TSC C++ code. You however rightly suppose
   that this static label is defined near to the combobox in the layout XML.
5. Time to find out which the layout XML file we need is. To do that,
   find out where `p_root` receives its value. You find this line:

       CEGUI::Window* p_root = CEGUI::System::getSingleton().getDefaultGUIContext().getRootWindow();

6. Bummer. This is a shortcut to retrieve the current root window from
   CEGUI rather than loading it from the XML file. The window needs to
   have been loaded before obviously. You bang your head
   against the table.
7. By virtuous power of the search function of your editor you used to
   search for the string `.layout` (the file extension of CEGUI layout
   files, luckily used consequently in TSC), you finally find that
   from the 10 layout files loaded in `menu_data.cpp`, the one loaded
   in `cMenu_Options::Init_GUI()` looks most promising, because it's used
   in the same class that the code operating the combobox is in. Thus,
   you find the line

       CEGUI::Window* tabwindow = wmgr.loadLayoutFromFile("menu/tab_game.layout");

8. Appearently at some point `tabwindow` or one of its parents
   advances to be the CEGUI root window, but you won't worry about
   this detail for the moment.
9. Using the information from step 7, you finally find that the
   relevant layout XML file is the one in
   `tsc/data/gui/layouts/menu/tab_game.layout`. That is, the argument
   to `loadLayoutFromFile()` is a path relative to
   `tsc/data/gui/layouts` (which is the path for layout files
   advertised to CEGUI at game startup, as was explained earlier).
10. Using the search function on that file you find first the
   definition for the combobox. That is not interesting. Searching
   further reveals:

       <Window type="TaharezLook/StaticText" name="game_text_always_run">
       <Property name="Text" value="Always Run"/>

11. Perfect. This is the static text containing the "Always Run" label
    next to the combobox! Take note of the value of the `name`
    attribute. It identifies this GUI element relative to its parent
    element. The containing XML element describes this parent; it's
    `name` attribute is set to `tab_game`. This means that the
    combobox and the static text share the same parent element (which
    you also easily verify by looking for the combobox' XML again).
12. Returning to `cMenu_Options::Init_GUI_Game()`, you can now apply
    the translation hack. From the information in steps 11 and 3, you
    can now construct the full path to the static label showing the
    string "Always Run":
    `options/window_options/tabcontrol_main/tab_game/game_text_always_run`. Use
    that path to retrieve the label from the CEGUI root window
    downwards, just as was done with the combobox:

        CEGUI::Window* text_always_run = static_cast<CEGUI::Window*>(p_root->getChild("options/window_options/tabcontrol_main/tab_game/game_text_always_run"));

13. Now you can finally translate the label. Add this line:

      text_always_run->setText(UTF8_("Always Run"));

   `UTF_8()` is the translation macro that will query Gettext for the
   translation of its argument; see above already. `setText()`
   overwrites the label with its return value.
14. Update the POT file, update a language file, translate, recompile
    TSC. The label should now show the translated content.
