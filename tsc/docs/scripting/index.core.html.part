<h1>TSC Scripting API documentation</h1>

<p>
  These are the Secret Chronicles of the Scripting API documentation,
  directly from Dr. M.’s collection of rare books. It lists all objects
  available from within a level’s script together with their methods.
</p>

<p>
  TSC scripting is implemented with
  <a href="https://github.com/mruby/mruby">MRuby/<a>, a minimal
  implementation of the <a href="http://www.ruby-lang.org">Ruby programming language</a>.
  Although it’s not a hard-to-grasp language and intends
  to be as human-readable as possible, it tries to not sacrifice
  principles of powerful object-oriented programming. So, while you may
  understand and even write scripts without a thorough knowledge of the
  Ruby language, the key to mastering TSC’s scripting mechanism is an at
  least rudimental understand of Ruby.
</p>

<p>
  For those that are already familiar with the canonical Ruby
  interpreter ("MRI") or one of the other great Ruby implementations
  such as Rubinius or JRuby, let me point out that the "m" in "mruby"
  really stands for "minimal". Don’t expect to get a fully-featured Ruby
  implementation, especially regarding the standard library or <i>RubyGems</i>,
  which are simply missing. However, the language core itself should
  mostly be the way you expect it.
</p>

<h2>Interaction with C++</h2>

<p>
  TSC is written in C++. As such, all method calls that actually <em>do</em>
  anything in the gameplay must be translated to C++ function calls. For
  this to happen, each TSC-related mruby object is wrapped around a C++
  pointer that points to the actual underlying C++ object. Whenever you
  call a method on the mruby object, that method unwraps the C++
  pointer, translates the mruby arguments you hand to the method to
  types usable for C++ and then calls the C++ object’s corresponding
  function. On returning, the same process happens in reverse order.
</p>

<p>
  While this knowledge may not seem important to you, it may help you
  fixing obscure problems related to the fact the mruby objects are
  independent from the underlying C++ pointers.
</p>

<h2>Object types</h2>

<p>
  There are two ways to interact with TSC objects. The first way is to
  get hold of an object already existing in the level, for example an
  enemy or a block. The other way is to actively <em>create</em> an object
  yourself, by calling the corresponding object’s <code>::new</code> method.
</p>

<p>
  Once you have an mruby object you can interact with, there’s no
  difference anymore between mruby objects build up around existing C++
  ones and mruby objects that were created together with a C++ object.
</p>

<h3>Retrieval of existing objects</h3>

<p>
  Each sprite created via the regular TSC editor (a so-called <em>internal</em>
  sprite) is assigned an identifier that is unique for the whole of the
  current level, hence it is called <em>unique identifier</em>, or short
  <em>UID</em>. You can determine an internal sprite’s UID by loading
  your level into the TSC editor and hover the cursor over the object
  whose UID you want to know; there the UID is displayed next to the
  coordinates of the object. These UIDs are guaranteed to stay the same
  between multiple level loads and even level editing (however, deleting
  an object in the editor will release its UID and make it available to
  other sprites). TSC maintains a global MRuby object
  called <code>UIDS</code> that references a table which maps all known
  UIDs to specific instances of
  class <a href="core/sprite.html">Sprite</a>) or one of its subclasses.
</p>

<p>
  In order to actually create an mruby object for an existing C++ object
  in the level, your way goes through that <code>UIDS</code> object. It provides
  you with a method <code>::[]</code> that determines what C++ pointer belongs to
  the UID you pass it, wraps an mruby object around the pointer and
  finally returns that mruby object to you. The returned mruby object is
  then cached, so if you query <code>UIDS</code> again with the same UID, you will
  get the <em>exact same object</em> back as for the first time you queried.
</p>

<p>
  For example, if you wanted to unblock a path by moving a block with
  UID 38 away:
</p>

<pre class="source">
# Note that (-100|100) is outside the visible area,
# therefore it looks as if the block "disappeared".
block = UIDS[38]
block.warp(-100, 100)
</pre>

<h3>Creation of new objects</h3>

<p>
  As mentioned above, there’s a second way to interact with the
  level. Instead of passively retrieving existing objects and
  interacting with them, you can actually <em>create</em> new things and place
  them in the level. To achieve this, call the corresponding class’
  <code>::new</code> method, which will generate a new C++ pointer and a new mruby
  object for that pointer, with all its attributes set to TSC’s default
  values for that type.
</p>

<p>
  As an example, here’s how you would proceed for spawning a furball:
</p>

<pre class="source">
furball = Furball.new
furball.start_direction = :right
furball.start_at(300, -300)
furball.show
</pre>

<p>
  The first line as explained generates a new furball. We then make that
  furball look into the right, while (line 3) it initially appears at
  position <code>(300|-300)</code>. From the moment you call the <code>#show</code> method on,
  your settings will take effect and the new furball takes part in the
  gameplay.
</p>

<p>
  Hint: Don’t forget to call <code>#show</code> on your generated objects,
  otherwise they won’t show up at all.
</p>

<p>
  These generated or <em>external</em> sprites are automatically marked as
  <em>generated</em> objects and hence are <strong>not</strong> saved
  when the user creates a new savegame! If you want to preserve your
  generated objects through saving/loading a savegame, you have to
  register for specific events on the level; see the documentation on
  <a href="ssl/levelclass.html">Level</a> for more information on this.
</p>

<h2>Events</h2>

<p>
  The scripting API uses an event-driven approach, i.e. whenever you’re
  interested in intercepting a given action, you’re going to register an
  <em>event handler</em> for a specific <em>event</em>. Each event is a bit different,
  especially regarding the information they pass in form of arguments to
  their event handlers, but the process of registering for an event is
  always the same.
</p>

<ol>
  <li>You want to listen for a specific event, e.g. the <code>touch</code> event.</li>
  <li>
    You write an event handler accepting the parameters the event will
    hand to you (e.g. the other sprite in case of the <code>touch</code>
    event).
  </li>
  <li>
    You register the handler by calling the
    object’s <code>on_&lt;eventname&gt;</code> method,
    e.g. <code>on_touch</code> for the <code>touch</code> event, and
    passing it the function you wrote.
  </li>
</ol>

<p>
  The registering methods are always
  named <code>on_&lt;downcased_eventname&gt;</code>, so once you know
  which event to listen for, registering it is quite simple. For
  example, if you want to kill the player when he collides with the
  object with UID 38, you’d do:
</p>

<pre class="source">
UIDS[38].on_touch do |other|
other.kill! if other.player?
end
</pre>

<p>
  Furthermore, events are inherited. This allows you for example to
  register for the <code>touch</code> event of a Furball, which somewhere up the
  inheritance chain is a Sprite (where the <code>touch</code> event is initially
  defiend). Therefore, if you don’t find the event you’re looking for in
  your object’s class’ documentation, try the superclass’ documentation.
</p>

<h2>Organisation of the documentation</h2>

<o>
  The documentation is created by a helper program called
  <code>scrdg</code> (“Scripting Documentation Generator”) in the TSC
  source tree. This program parses the C++ files implementing the
  scripting interface and extract specifcally marked documentation
  comments, transforms them into HTML and writes them out to the
  <code>scriptdocs/</code> directory below your build directory. Most
  likely you’re looking at the <code>index.html</code> file in this
  directory now (if not, you’re reading the HTML sources directly).
</p>

<p>
  The documentation is divided into the classes which you can access
  from the MRuby side. Their descriptions always start with a general
  overview of what the class/the singleton is supposed to be used for,
  followed by the list of events and then a list of methods:
</p>

<ol>
  <li>
    The class methods. These are methods you can directly call on the
    class object, without having to create an instance of that class.
    When referencing class methods in the documentation, we will
    always use a double-colon like this: <code>Furball::new</code> means the
    <code>new()</code> method on the <code>Furball</code> class.
  </li>
  <li>
    The instance methods. These are methods you can call on instances
    of the respective class. When referencing instance methods in the
    documentation, we will alawys use a hash symbol like
    this: <code>MovingSprite#warp</code> refers to
    the <code>warp()</code> method of objects of
    type <code>MovingSprite</code>.
  </li>
</ol>

<p>
  Each method is introduced using its name, followed by a list of one or
  more possible call sequences. A call sequence may look like this:
</p>

<pre>
play_sound( filename [, volume [, loops [, resid ] ] ] ) → a_bool
</pre>

<p>
  This can serve as a quick reference on how to use the method. It tells
  you that the <code>filename</code> parameter is required (because it isn’t
  included in any brackets), but the other ones, like <code>volume</code> or
  <code>resid</code>, are optional and don’t have to be passed. Fitting default
  values will be assumed (the exact default values can be found in the
  <em>Parameters</em> section of the respective method, where it is included in
  parantheses after the parameter’s name). Finally, the → indicates that
  the methods returns something (there exist quite a number of methods
  that actually do <em>not</em> return anything interesting), and that this
  something is <code>a_bool</code>, i.e. <code>true</code> or <code>false</code>. You don’t have
  to care for the return value if you don’t want to.
</p>

<p>
  The method description continues with a detailed look on the parameter
  list, describing each parameter and its default value (as already
  explained above).
</p>

<p>
  After this, the documentation may include a short paragraph about the
  exact nature of the return value (if it’s not obvious from the name or
  the call sequence).
</p>

<p>
  And finally, if you’re lucky the method’s documentation may contain
  some usage examples of the method. But again, this may not be the case
  for all methods.
</p>

<h2>The Standard Scripting Library</h2>

At the bottom of this file, you find a list of all built-in core
objects of the TSC scripting environments. These are usually simply
referred to as "the core" and are available always without you having
to to anything. On top of this, there exist some "helper" classes
called the "standard scripting library", or SSL for short. The SSL
contains classes that built upon the functionality provided by the
core and extend them in such a way a specific task is easier to
achieve than by utilizing the core stuff "rawly". As a major
difference to the core classes, which are implemented in C++, the SSL
is solely written in Ruby code. You can find it in the scripting/std
folder of your TSC data path.
</p>

<p>
  The SSL is documented in a <a href="../ssl/">separate set of
    documents</a>.
</p>

<p>
  In order to use these standard extensions, you have to <code>require</code>
  them. You can choose between loading the entire standard library at
  once, which can slow down level startup and will likely pull in many
  things you don’t even use, and loading specific helpers directly, thus
  resulting in probably many <code>require</code> statements on the top of your
  level code. Due to the performance gain however, the latter choice is
  preferred.
</p>

<p>
  To load the entire SSL, simply place this at the top of your scripting
  code:
</p>

<pre class="source">
TSC.require "std/all"
</pre>

<p>
  If you want to load specific helpers like the <code>ImmediateSprite</code> class
  that allows you to create static sprites quickly, do it like this
  instead:
</p>

<pre class="source">
TSC.require "std/immediate_sprite"
</pre>

<p>
  In either case, you could then use <code>ImmediateSprite</code> like this:
</p>

<pre class="source">
Std::ImmediateSprite.new("blocks/extra/corded.png", x: 300, y: -300)
</pre>

<p>
  which will create, place, and show a corded block at the given
  coordinates.
</p>

<p>
  Note that all standard library stuff is defined under the <code>Std</code>
  namespace. Do <strong>not</strong> use that namespace for your own scripting
  expansion packs (see below).
</p>

<h2>Scripting expansion packs</h2>

<p>
  As already noted, the SSL is written entirely in Ruby, without any C++
  involved. This allows you to provide <em>your very own</em> helper classes to
  be defined exactly the same way. Choose a namespace for your lib,
  <code>Freaky</code> for instance, and then place your own code below that.
</p>

<pre class="source">
module Freaky

class FreakyThing &lt; Furball
  # Your code...
end

end
</pre>

<p>
  Each class should have its own file, and all files related to the
  "freaky" expansion-pack should reside in a folder "freaky/". That
  folder should also contain a file "all.rb" that pulls in all classes
  under the <code>Freaky</code> namespace so a user can require them all at once
  the same way as the SSL shown above. When you’re done, place the
  "freaky/" folder next to the "std/" folder in your TSC’s "scripting/"
  directory. You will then be able to <code>TSC.require</code> files from below
  that folder. To get an impression of how all that works, you can
  always look on the SSL’s code itself.
</p>

<p>
  You can also create a ZIP file or Tarball from your "freaky/" folder
  and upload it to the Internet, so everybody can download it an add it
  to their own TSC installation. These ZIP or Tarball files are then
  called a <em>scripting expansion pack</em>. If you publish one, please
  accompany it with some kind of license, so others can build upon
  it. Ask on the TSC forums if you’re unsure what that means.
</p>

<h2>List of core classes and modules</h2>

<!-- scrdg inserts here -->
