# -*- coding: utf-8; mode: ruby -*-
#############################################################################
# Rakefile  -  Rake instruction file
#
# Copyright © 2012-2017 The TSC Contributors
#############################################################################
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

require "rake"
require "rake/clean"
require "pathname"

CLOBBER.include("build", "crossbuild", "docs/scripting/html", "docs/scripting/rdoc", "docs/api", "docs/ssl")

str = File.read("CMakeLists.txt", :encoding => "utf-8")
TSC_VERSION_MAJOR = str.match(/^set\(TSC_VERSION_MAJOR (\d+)\)/)[1]
TSC_VERSION_MINOR = str.match(/^set\(TSC_VERSION_MINOR (\d+)\)/)[1]
TSC_VERSION_PATCH = str.match(/^set\(TSC_VERSION_PATCH (\d+)\)/)[1]

TSC_SOURCE_FILES = FileList["src/**/*.cpp"] + FileList["src/**/*.hpp"]

desc "Generate the documentation in the directory htmldocs/."
task :docs => ["docs:doxygen", "docs:scripting_core_docs", "docs:scripting_ssl_docs"]

desc "Update all copyright notices to the current year."
task :update_copyright do
  FileList["src/**/*.{cpp,hpp}", "docs/**/*.css", "cmake/**/*.cmake",
           "CMakeLists.txt", "extras/archlinux/*", "extras/*.desktop",
           "*.rb", "Rakefile", "rakelib/**/*.rake", "../README.md"].each do |path|

    if File.directory?(path)
      puts "Skipping directory #{path}"
      next
    else
      print "Processing #{path}... "
    end

    str = File.read(path)
          .sub(/Copyright (©|\(C\)) .* The TSC Contributors/,
               "Copyright © 2012-#{Time.now.year} The TSC Contributors")

    open(path, "w"){ |f| f.write(str) }
    puts "ok"
  end
end

desc "Create source tarball."
task :tarball => :clobber do
  version = ENV["VERSION"] || "#{TSC_VERSION_MAJOR}.#{TSC_VERSION_MINOR}.#{TSC_VERSION_PATCH}"
  puts "Packaging TSC version #{version}"
  sleep 1

  sh "git submodule init"
  sh "git submodule update"

  project_dir = File.expand_path(File.join(File.dirname(__FILE__), ".."))
  cd "../.." do
    ln_s project_dir, "TSC-#{version}" unless File.exist?("TSC-#{version}")
    sh "tar --exclude .git --exclude drafts -cvJhf TSC-#{version}.tar.xz TSC-#{version}"
    rm "TSC-#{version}"
  end
end

desc "Create all files necessary for a release."
task :release do
  version = ENV["VERSION"] || "#{TSC_VERSION_MAJOR}.#{TSC_VERSION_MINOR}.#{TSC_VERSION_PATCH}"
  prerelease = version.include?("-")
  puts "Building release files for TSC version #{version}"

  if prerelease
    puts "This is a prerelease version."
  else
    print "This is the FINAL version. Are you sure you want to continue (y/n)? "
    fail "Aborted by user" unless $stdin.gets.chomp.downcase == "y"
  end

  if ENV["TSCSIGNKEY"]
    gpgkey = ENV["TSCSIGNKEY"].strip
  else
    puts "$TSCSIGNKEY is unset! Please specify your GPG key to use for"
    puts "signing the source package."
    print "GPG Key ID: "
    gpgkey = $stdin.gets.chomp

    if gpgkey.empty?
      raise "No GPG key specified. Exiting."
    end
  end

  if ENV["TSCCROSSCOMPILEPATH"]
    crosspath = ENV["TSCCROSSCOMPILEPATH"]
  else
    puts "$TSCCROSSCOMPILEPATH is unset. Please specify the value for the $PATH"
    puts "variable to use when crosscompiling for Windows."
    print "$PATH: "
    crosspath = $stdin.gets.chomp

    if crosspath.empty?
      puts "No extra crosspath specified. Assuming regular $PATH works."
      crosspath = ENV["PATH"]
    end
  end

  if ENV["TSCTARGETPATH"]
    targetpath = ENV["TSCTARGETPATH"]
  else
    puts "$TSCTARGETPATH is unset. /tmp/tsc-release will be used instead."
    print "Is that ok? (y/n) "
    if $stdin.gets.chomp.downcase != "y"
      raise "$TSCTARGETPATH unset and default rejected."
    else
      targetpath = "/tmp/tsc-release"
    end
  end

  source_tarball = File.join(Dir.pwd, "..", "..", "TSC-#{version}.tar.xz")

  unless File.file?(source_tarball)
    raise "Something went wrong. There is no source tarball at '#{source_tarball}'. You should run `$ rake tarball' probably?"
  end

  mkdir targetpath
  cd targetpath  do
    # First create the native build. While not required strictly for releasing,
    # this ensures the code compiles.
    mkdir "native"
    cd "native" do
      sh "tar -xJf '#{source_tarball}'"
      cd "TSC-#{version}/tsc" do
        mkdir "build"
        cd "build" do
          sh "cmake #{prerelease ? '-DCMAKE_BUILD_TYPE=Debug' : '-DCMAKE_BUILD_TYPE=Release'} -DCMAKE_INSTALL_PREFIX=#{Dir.pwd}/testinstall .."
          sh "make -j#{`nproc`.strip}"
          sh "make install"

          puts ">>>>> Running the game now. Test a bit and close when you are satisfied. <<<<<"
          print "Press [ENTER] to start"
          $stdin.gets
          sh "#{Dir.pwd}/testinstall/bin/tsc"
        end
      end
    end

    # Now create the Windows setup installer
    mkdir "win32"
    cd "win32" do
      sh "tar -xJf '#{source_tarball}'"
      cd "TSC-#{version}/tsc" do
        mkdir "crossbuild"
        cd "crossbuild" do
          puts "Adjusting $PATH for crosscompiling to '#{crosspath}'"
          ENV["PATH"] = crosspath

          cp "../cmake/toolchains/linux2mingw32.cmake", "."
          sh "cmake #{prerelease ? '-DCMAKE_BUILD_TYPE=Debug' : '-DCMAKE_BUILD_TYPE=Release'} -DCMAKE_TOOLCHAIN_FILE=linux2mingw32.cmake .."
          sh "make -j#{`nproc`.strip}"
          sh "i686-pc-mingw32-strip -x tsc.exe"
          sh "cpack -G NSIS"
        end
      end
    end

    mkdir "files"
    cd "files" do
      # Collect the files
      cp source_tarball, "."
      cp "../win32/TSC-#{version}/tsc/crossbuild/TSC-#{TSC_VERSION_MAJOR}.#{TSC_VERSION_MINOR}.#{TSC_VERSION_PATCH}-win32.exe", "TSC-#{version}-win32.exe"

      tarballfile = File.basename(source_tarball)
      win32exefile = "TSC-#{version}-win32.exe"

      # Sign them
      sh "gpg --local-user #{gpgkey} --detach-sign #{tarballfile}"
      sh "gpg --local-user #{gpgkey} --detach-sign #{win32exefile}"

      # Generate checksums
      sh "md5sum #{tarballfile} #{win32exefile} > TSC-#{version}.md5sums"
      sh "sha256sum #{tarballfile} #{win32exefile} > TSC-#{version}.sha256sums"

      puts
      sh "ls -hl"
    end
  end

  puts "===== DONE ====="
  puts "All files required for releasing are in #{targetpath}/files."
  puts "Don’t forget to add a signed Git tag (-s or -u option) to the repository."
end

desc "Run optipng on all PNG graphics to cut size down."
task :optipng do
  pngs = Dir["data/pixmaps/**/*.png"].sort

  # Ensure we have optipng available
  optipng = `which optipng`.strip
  fail "optipng not available" if optipng.empty?

  total_size = pngs.reduce(0){|sum, path| sum + File.size(path)}
  puts "Current total size of all PNGs: #{bytesize(total_size)}"

  # Ensure we use all the CPU cores available. This takes far
  # too long otherwise.
  mutex = Mutex.new
  commands = pngs.map{|path| [optipng, "-q", "-o4", "--", path]}
  threads = []
  `nproc`.to_i.times do |i|
    threads << Thread.new do
      loop do
        cmd = mutex.synchronize{commands.pop}
        break if cmd.nil?

        print "[#{i}] "
        puts cmd.join(" ")
        system(*cmd)
      end
    end
  end
  threads.each(&:join)

  new_total_size = pngs.reduce(0){|sum, path| sum + File.size(path)}
  puts "Old total size of all PNGs: #{bytesize(total_size)}"
  puts "New total size of all PNGs: #{bytesize(new_total_size)}"
  puts "Reduction in size thus is:  #{bytesize(total_size - new_total_size)}"
end

########################################
# Helper methods

def bytesize(bytes)
  if bytes < 1024
    "#{bytes} B"
  elsif bytes < 1024 * 1024
    "#{bytes / 1024}kB #{bytes % 1024} B"
  elsif bytes < 1024 * 1024 * 1024
    kb = bytes / 1024
    bytes = bytes % 1024
    mib = kb / 1024
    kb = kb % 1024
    "#{mib} MiB #{kb} kB #{bytes} B"
  elsif bytes < 1024 * 1024 * 1024
    kb = bytes / 1024
    bytes = bytes % 1024
    mib = kb / 1024
    kb = kb % 1024
    gib = mib / 1024
    mib = mib % 1024
    "#{gib} GiB #{mib} MiB #{kb} kB #{bytes} B"
  else # Some large number
    "#{bytes} B"
  end
end
